// Code generated by carrier, DO NOT EDIT.
{{"package factory"}}

import (
{{range .Imports}}
    "{{.}}"
{{end}}
"context"
)
{{ $Prefix := .Prefix  }}
{{ $EntSchema := $Prefix | eq "Ent"  }}
{{ $RawSchemaName := .Schema.Name  }}
{{ $SchemaType := .Schema.Type  }}
{{ $SchemaName := .Schema.Name | printf "%s%s" $Prefix  }}
{{ $CreatedType := .Schema.Type  }}
{{ $EntPkg := .Schema.EntPkg }}
{{if $EntSchema}}
    {{ $SchemaType = $SchemaName | printf "%sMutator" }}
{{end}}

{{with .Schema}}
    {{if $EntSchema}}
	type {{$SchemaName}}Mutator struct {
	{{range .Fields}}
	    {{.Name}} {{.ValueType}}
	{{end}}
	}
    {{end}}
    type {{$SchemaName | FirstLower}}Mutation struct {
    {{range .Fields}}
	{{$DynamicParams := ""}}
	{{if $EntSchema}}
	    {{$DynamicParams = $RawSchemaName | printf "creator *%s.%sCreate" $EntPkg}}
	{{end}}
	{{.Name | FirstLower}}Type int
	{{.Name | FirstLower}}Func func(ctx context.Context, i *{{$SchemaType}}, c int, {{$DynamicParams}}) error
    {{end}}
    {{range .PostFields}}
	_post{{.Name}}Func func(ctx context.Context, set bool, obj *{{$CreatedType}}, i {{.ValueType}}) error
    {{end}}
    afterCreateFunc func(ctx context.Context, i *{{$CreatedType}}) error
    }
    type {{$SchemaName}}MetaFactory struct {
    mutation {{$SchemaName | FirstLower}}Mutation
    {{range .Traits}}
	{{. | FirstLower}}Trait *{{$SchemaName | FirstLower}}Trait
    {{end}}
    }
    type {{$SchemaName | FirstLower}}Trait struct {
    mutation {{$SchemaName | FirstLower}}Mutation
    updates []func(m *{{$SchemaName | FirstLower}}Mutation)
    }
    func {{$SchemaName}}Trait() *{{$SchemaName | FirstLower}}Trait {
    return &{{$SchemaName | FirstLower}}Trait{}
    }
    func (*{{$SchemaName | FirstLower}}Mutation) afterCreateMutateFunc(fn func(ctx context.Context, i *{{$CreatedType}}) error) func(m *{{$SchemaName | FirstLower}}Mutation) {
    return func(m *{{$SchemaName | FirstLower}}Mutation) {
    m.afterCreateFunc = fn
    }
    }
    {{range .Fields}}
	{{$DynamicParams := ""}}
	{{if $EntSchema}}
	    {{$DynamicParams = $RawSchemaName | printf "creator *%s.%sCreate" $EntPkg}}
	{{end}}
	func (*{{$SchemaName | FirstLower}}Mutation) {{.Name | FirstLower}}SequenceMutateFunc(fn func(ctx context.Context, i int) ({{.ValueType}}, error)) func(m *{{$SchemaName | FirstLower}}Mutation) {
	return func(m *{{$SchemaName | FirstLower}}Mutation) {
	m.{{.Name | FirstLower}}Type = TypeSequence
	m.{{.Name | FirstLower}}Func = func(ctx context.Context, i *{{$SchemaType}}, c int, {{$DynamicParams}}) error {
	if fn == nil {
	return nil
	}
	value, err := fn(ctx, c)
	if err != nil {
	return err
	}
	{{if $EntSchema}}
	    creator.{{.Setter}}(value)
	{{end}}
	i.{{.Name}} = value
	return nil
	}
	}
	}
	func (*{{$SchemaName | FirstLower}}Mutation) {{.Name | FirstLower}}LazyMutateFunc(fn func(ctx context.Context, i *{{$SchemaType}}) ({{.ValueType}}, error)) func(m *{{$SchemaName | FirstLower}}Mutation) {
	return func(m *{{$SchemaName | FirstLower}}Mutation) {
	m.{{.Name | FirstLower}}Type = TypeLazy
	m.{{.Name | FirstLower}}Func = func(ctx context.Context, i *{{$SchemaType}}, c int, {{$DynamicParams}}) error {
	if fn == nil {
	return nil
	}
	value, err := fn(ctx, i)
	if err != nil {
	return err
	}
	{{if $EntSchema}}
	    creator.{{.Setter}}(value)
	{{end}}
	i.{{.Name}} = value
	return nil
	}
	}
	}
	func (*{{$SchemaName | FirstLower}}Mutation) {{.Name | FirstLower}}DefaultMutateFunc(v {{.ValueType}}) func(m *{{$SchemaName | FirstLower}}Mutation) {
	return func(m *{{$SchemaName | FirstLower}}Mutation) {
	m.{{.Name | FirstLower}}Type = TypeDefault
	m.{{.Name | FirstLower}}Func = func(ctx context.Context, i *{{$SchemaType}}, c int, {{$DynamicParams}}) error {
	{{if $EntSchema}}
	    creator.{{.Setter}}(v)
	{{end}}
	i.{{.Name}} = v
	return nil
	}
	}
	}
	func (*{{$SchemaName | FirstLower}}Mutation) {{.Name | FirstLower}}FactoryMutateFunc(fn func(ctx context.Context) ({{.ValueType}}, error)) func(m *{{$SchemaName | FirstLower}}Mutation) {
	return func(m *{{$SchemaName | FirstLower}}Mutation) {
	m.{{.Name | FirstLower}}Type = TypeFactory
	m.{{.Name | FirstLower}}Func = func(ctx context.Context, i *{{$SchemaType}}, c int, {{$DynamicParams}}) error {
	if fn == nil {
	return nil
	}
	value, err := fn(ctx)
	if err != nil {
	return err
	}
	{{if $EntSchema}}
	    creator.{{.Setter}}(value)
	{{end}}
	i.{{.Name}} = value

	return nil
	}
	}
	}
	// Set{{.Name}}Sequence register a function which accept a sequence counter and set return value to {{.Name}} field
	func (f *{{$SchemaName}}MetaFactory) Set{{.Name}}Sequence(fn func(ctx context.Context, i int) ({{.ValueType}}, error)) *{{$SchemaName}}MetaFactory {
	f.mutation.{{.Name | FirstLower}}SequenceMutateFunc(fn)(&f.mutation)
	return f
	}
	// Set{{.Name}}Lazy register a function which accept the build struct and set return value to {{.Name}} field
	func (f *{{$SchemaName}}MetaFactory) Set{{.Name}}Lazy(fn func(ctx context.Context, i *{{$SchemaType}}) ({{.ValueType}}, error)) *{{$SchemaName}}MetaFactory {
	f.mutation.{{.Name | FirstLower}}LazyMutateFunc(fn)(&f.mutation)
	return f
	}
	// Set{{.Name}}Default assign a default value to {{.Name}} field
	func (f *{{$SchemaName}}MetaFactory) Set{{.Name}}Default(v {{.ValueType}}) *{{$SchemaName}}MetaFactory {
	f.mutation.{{.Name | FirstLower}}DefaultMutateFunc(v)(&f.mutation)
	return f
	}
	// Set{{.Name}}Factory register a factory function and assign return value to {{.Name}}, you can also use related factory's Create/CreateV as input function here
	func (f *{{$SchemaName}}MetaFactory) Set{{.Name}}Factory(fn func(ctx context.Context) ({{.ValueType}}, error)) *{{$SchemaName}}MetaFactory {
	f.mutation.{{.Name | FirstLower}}FactoryMutateFunc(fn)(&f.mutation)
	return f
	}
	// Set{{.Name}}Sequence register a function which accept a sequence counter and set return value to {{.Name}} field
	func (t *{{$SchemaName | FirstLower}}Trait) Set{{.Name}}Sequence(fn func(ctx context.Context, i int) ({{.ValueType}}, error)) *{{$SchemaName | FirstLower}}Trait {
	t.updates = append(t.updates, t.mutation.{{.Name | FirstLower}}SequenceMutateFunc(fn))
	return t
	}
	// Set{{.Name}}Lazy register a function which accept the build struct and set return value to {{.Name}} field
	func (t *{{$SchemaName | FirstLower}}Trait) Set{{.Name}}Lazy(fn func(ctx context.Context, i *{{$SchemaType}}) ({{.ValueType}}, error)) *{{$SchemaName | FirstLower}}Trait {
	t.updates = append(t.updates, t.mutation.{{.Name | FirstLower}}LazyMutateFunc(fn))
	return t
	}
	// Set{{.Name}}Default assign a default value to {{.Name}} field
	func (t *{{$SchemaName | FirstLower}}Trait) Set{{.Name}}Default(v {{.ValueType}}) *{{$SchemaName | FirstLower}}Trait {
	t.updates = append(t.updates, t.mutation.{{.Name | FirstLower}}DefaultMutateFunc(v))
	return t
	}
	// Set{{.Name}}Factory register a factory function and assign return value to {{.Name}}, you can also use related factory's Create/CreateV as input function here
	func (t *{{$SchemaName | FirstLower}}Trait) Set{{.Name}}Factory(fn func(ctx context.Context) ({{.ValueType}}, error)) *{{$SchemaName | FirstLower}}Trait {
	t.updates = append(t.updates, t.mutation.{{.Name | FirstLower}}FactoryMutateFunc(fn))
	return t
	}
    {{end}}
    {{range .PostFields}}
	func (*{{$SchemaName | FirstLower}}Mutation) {{.Name | FirstLower}}PostMutateFunc(fn func(ctx context.Context, set bool, obj *{{$CreatedType}}, i {{.ValueType}}) error) func(m *{{$SchemaName | FirstLower}}Mutation) {
	return func(m *{{$SchemaName | FirstLower}}Mutation) {
	m._post{{.Name}}Func = fn
	}
	}
	// Set{{.Name}}PostFunc register a post function which will be called in factory Set{{.Name}}Post method
	func (f *{{$SchemaName}}MetaFactory) Set{{.Name}}PostFunc(fn func(ctx context.Context, set bool, obj *{{$CreatedType}}, i {{.ValueType}}) error) *{{$SchemaName}}MetaFactory {
	f.mutation.{{.Name | FirstLower}}PostMutateFunc(fn)(&f.mutation)
	return f
	}
	func (t *{{$SchemaName | FirstLower}}Trait) Set{{.Name}}PostFunc(fn func(ctx context.Context, set bool, obj *{{$CreatedType}}, i {{.ValueType}}) error) *{{$SchemaName | FirstLower}}Trait {
	t.updates = append(t.updates, t.mutation.{{.Name | FirstLower}}PostMutateFunc(fn))
	return t
	}
    {{end}}
    {{range .Traits}}
	// Set{{.}}Trait accept a {{$SchemaName | FirstLower}}Trait, will override builder using Trait's methods if enable
	func (f *{{$SchemaName}}MetaFactory) Set{{.}}Trait(t *{{$SchemaName | FirstLower}}Trait) *{{$SchemaName}}MetaFactory {
	f.{{. | FirstLower}}Trait = t
	return f
	}
    {{end}}
    // SetAfterCreateFunc register a function to be called after struct create
    func (f *{{$SchemaName}}MetaFactory) SetAfterCreateFunc(fn func(ctx context.Context, i *{{$CreatedType}}) error) *{{$SchemaName}}MetaFactory {
    f.mutation.afterCreateFunc = fn
    return f
    }
    // SetAfterCreateFunc register a function to be called after struct create
    func (t *{{$SchemaName | FirstLower}}Trait) SetAfterCreateFunc(fn func(ctx context.Context, i *{{$CreatedType}}) error) *{{$SchemaName | FirstLower}}Trait {
    t.updates = append(t.updates, t.mutation.afterCreateMutateFunc(fn))
    return t
    }
    // Build create a  {{$SchemaName}}Factory from {{$SchemaName}}MetaFactory
    func (f *{{$SchemaName}}MetaFactory) Build() *{{$SchemaName}}Factory {
    return &{{$SchemaName}}Factory{meta: *f, counter: &Counter{}}
    }

    type {{$SchemaName}}Factory struct {
    meta    {{$SchemaName}}MetaFactory
    counter *Counter
    {{if $EntSchema}}
	client *{{$EntPkg}}.Client
    {{end}}
    }

    {{range .Fields}}
	// Set{{.Name}} set the {{.Name}} field
	func (f *{{$SchemaName}}Factory) Set{{.Name}}(i {{.ValueType}}) *{{$SchemaName}}Builder {
	builder := &{{$SchemaName}}Builder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.Set{{.Name}}(i)
	{{if $EntSchema}}
	    builder.client = f.client
	{{end}}
	return builder
	}
    {{end}}
    {{range .PostFields}}
	// Set{{.Name}}Post call the post function with {{.ValueType}} input
	func (f *{{$SchemaName}}Factory) Set{{.Name}}Post(i {{.ValueType}}) *{{$SchemaName}}Builder {
	builder := &{{$SchemaName}}Builder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.Set{{.Name}}Post(i)
	{{if $EntSchema}}
	    builder.client = f.client
	{{end}}
	return builder
	}
    {{end}}
    {{range .Traits}}
	// With{{.}}Trait() enable the {{.}} trait
	func (f *{{$SchemaName}}Factory) With{{.}}Trait() *{{$SchemaName}}Builder {
	builder := &{{$SchemaName}}Builder{mutation: f.meta.mutation, counter: f.counter}
	builder.factory = f
	{{if $EntSchema}}
	    builder.client = f.client
	{{end}}
	if f.meta.{{. | FirstLower}}Trait == nil {
	return builder
	}
	for _, u := range f.meta.{{. | FirstLower}}Trait.updates {
	u(&builder.mutation)
	}
	return builder
	}
    {{end}}
    // Create return a new *{{$CreatedType}}
    func (f *{{$SchemaName}}Factory) Create(ctx context.Context) (*{{$CreatedType}}, error) {
    builder := &{{$SchemaName}}Builder{mutation: f.meta.mutation, counter: f.counter, factory: f}
    {{if $EntSchema}}
	builder.client = f.client
    {{end}}
    return builder.Create(ctx)
    }
    // CreateV return a new {{$CreatedType}}
    func (f *{{$SchemaName}}Factory) CreateV(ctx context.Context) ({{$CreatedType}}, error) {
    builder := &{{$SchemaName}}Builder{mutation: f.meta.mutation, counter: f.counter, factory: f}
    {{if $EntSchema}}
	builder.client = f.client
    {{end}}
    return builder.CreateV(ctx)
    }
    // CreateBatch return a []*{{$CreatedType}} slice
    func (f *{{$SchemaName}}Factory) CreateBatch(ctx context.Context, n int) ([]*{{$CreatedType}}, error) {
    builder := &{{$SchemaName}}Builder{mutation: f.meta.mutation, counter: f.counter, factory: f}
    {{if $EntSchema}}
	builder.client = f.client
    {{end}}
    return builder.CreateBatch(ctx, n)
    }
    // CreateBatchV return a []{{$CreatedType}} slice
    func (f *{{$SchemaName}}Factory) CreateBatchV(ctx context.Context, n int) ([]{{$CreatedType}}, error) {
    builder := &{{$SchemaName}}Builder{mutation: f.meta.mutation, counter: f.counter, factory: f}
    {{if $EntSchema}}
	builder.client = f.client
    {{end}}
    return builder.CreateBatchV(ctx, n)
    }

    {{if $EntSchema}}
	// Client set ent client to {{$SchemaName}}Factory
	func (f *{{$SchemaName}}Factory) Client(c *{{$EntPkg}}.Client) *{{$SchemaName}}Factory {
	f.client = c
	return f
	}
    {{end}}

    type {{$SchemaName}}Builder struct {
    factory *{{$SchemaName}}Factory
    mutation {{$SchemaName | FirstLower}}Mutation
    counter  *Counter
    {{range .Fields}}
	{{.Name | FirstLower}}Override {{.ValueType}}
	{{.Name | FirstLower}}Overriden bool
    {{end}}
    {{range .PostFields}}
	_post{{.Name}} {{.ValueType}}
	_post{{.Name}}Set bool
    {{end}}
    {{if $EntSchema}}
	client *{{$EntPkg}}.Client
    {{end}}
    }
    {{if $EntSchema}}
	func (b *{{$SchemaName}}Builder) Client(c *{{$EntPkg}}.Client) *{{$SchemaName}}Builder {
	b.client = c
	return b
	}
    {{end}}
    {{range .Fields}}
	// Set{{.Name}} set the {{.Name}} field
	func (b *{{$SchemaName}}Builder) Set{{.Name}}(i {{.ValueType}}) *{{$SchemaName}}Builder {
	b.{{.Name | FirstLower}}Override = i
	b.{{.Name | FirstLower}}Overriden = true
	return b
	}
    {{end}}
    {{range .PostFields}}
	// Set{{.Name}}Post call the post function with {{.ValueType}} input
	func (b *{{$SchemaName}}Builder) Set{{.Name}}Post(i {{.ValueType}}) *{{$SchemaName}}Builder {
	b._post{{.Name}} = i
	b._post{{.Name}}Set = true
	return b
	}
    {{end}}
    {{range .Traits}}
	// With{{.}}Trait() enable the {{.}} trait
	func (b *{{$SchemaName}}Builder) With{{.}}Trait() *{{$SchemaName}}Builder {
	if b.factory.meta.{{. | FirstLower}}Trait == nil {
	return b
	}
	for _, u := range b.factory.meta.{{. | FirstLower}}Trait.updates {
	u(&b.mutation)
	}
	return b
	}
    {{end}}
    // CreateV return a new {{$CreatedType}}
    func (b *{{$SchemaName}}Builder) CreateV(ctx context.Context) ({{$CreatedType}}, error) {
    var d {{$CreatedType}}
    p, err := b.Create(ctx)
    if err == nil {d = *p}
    return d, err
    }
    // Create return a new *{{$CreatedType}}
    func (b *{{$SchemaName}}Builder) Create(ctx context.Context) (*{{$CreatedType}}, error) {
    {{if $EntSchema}}
	var preSlice = []func(ctx context.Context, i *{{$SchemaType}}, c int, creator *{{$EntPkg}}.{{.Name}}Create) error{}
	var lazySlice = []func(ctx context.Context, i *{{$SchemaType}}, c int, creator *{{$EntPkg}}.{{.Name}}Create) error{}
	var postSlice = []func(ctx context.Context, i *{{$CreatedType}}, c int, creator *{{$EntPkg}}.{{.Name}}Create) error{}
    {{else}}
	var preSlice = []func(ctx context.Context, i *{{$SchemaType}}, c int) error{}
	var lazySlice = []func(ctx context.Context, i *{{$SchemaType}}, c int) error{}
	var postSlice = []func(ctx context.Context, i *{{$CreatedType}}, c int) error{}
    {{end}}
    index := b.counter.Get()
    _ = index

    {{if $EntSchema}}
	client := b.client
	entBuilder := client.{{.Name}}.Create()
    {{end}}

    {{range .Fields}}
	{{$DynamicParams := ""}}
	{{if $EntSchema}}
	    {{$DynamicParams = $RawSchemaName | printf "creator *%s.%sCreate" $EntPkg}}
	{{end}}
	if b.{{.Name | FirstLower}}Overriden {
	preSlice = append(preSlice, func(ctx context.Context, i *{{$SchemaType}}, c int, {{$DynamicParams}}) error {
	value := b.{{.Name | FirstLower}}Override
	{{if $EntSchema}}
	    creator.{{.Setter}}(value)
	{{end}}
	i.{{.Name}} = value
	return nil
	})
	} else {
	switch b.mutation.{{.Name | FirstLower}}Type {
	case TypeDefault:
	preSlice = append(preSlice, b.mutation.{{.Name | FirstLower}}Func)
	case TypeLazy:
	lazySlice = append(lazySlice, b.mutation.{{.Name | FirstLower}}Func)
	case TypeSequence:
	preSlice = append(preSlice, b.mutation.{{.Name | FirstLower}}Func)
	case TypeFactory:
	preSlice = append(preSlice, b.mutation.{{.Name | FirstLower}}Func)
	}
	}
    {{end}}
    {{range .PostFields}}
	{{$DynamicParams := ""}}
	{{if $EntSchema}}
	    {{$DynamicParams = $RawSchemaName | printf "creator *%s.%sCreate" $EntPkg}}
	{{end}}
	if b.mutation._post{{.Name}}Func != nil {
	postSlice = append(postSlice, func(ctx context.Context, i *{{$CreatedType}}, c int, {{$DynamicParams}}) error {
	err := b.mutation._post{{.Name}}Func(ctx, b._post{{.Name}}Set, i, b._post{{.Name}})
	return err
	})
	}
    {{end}}

    v := &{{$SchemaType}}{}
    for _, f := range preSlice {
    {{if $EntSchema}}
	err := f(ctx, v, index, entBuilder)
    {{else}}
	err := f(ctx, v, index)
    {{end}}
    if err != nil {
    return nil, err
    }
    }
    for _, f := range lazySlice {
    {{if $EntSchema}}
	err := f(ctx, v, index, entBuilder)
    {{else}}
	err := f(ctx, v, index)
    {{end}}
    if err != nil {
    return nil, err
    }
    }
    {{if $EntSchema}}
	new, err := entBuilder.Save(ctx)
	if err != nil {
	return nil, err
	}
    {{else}}
	new := v
    {{end}}
    if b.mutation.afterCreateFunc != nil {
    err := b.mutation.afterCreateFunc(ctx, new)
    if err != nil {
    return nil, err
    }
    }
    for _, f := range postSlice {
    {{if $EntSchema}}
	err := f(ctx, new, index, entBuilder)
    {{else}}
	err := f(ctx, new, index)
    {{end}}
    if err != nil {
    return nil, err
    }
    }

    return new, nil
    }
    func (b *{{$SchemaName}}Builder) CreateBatch(ctx context.Context, n int) ([]*{{$CreatedType}}, error) {
    var results []*{{$CreatedType}}
    for i := 0; i < n; i++ {
    d, err := b.Create(ctx)
    if err != nil {
    return results, err
    }
    results = append(results, d)
    }
    return results, nil
    }
    func (b *{{$SchemaName}}Builder) CreateBatchV(ctx context.Context, n int) ([]{{$CreatedType}}, error) {
    var results []{{$CreatedType}}
    for i := 0; i < n; i++ {
    d, err := b.CreateV(ctx)
    if err != nil {
    return results, err
    }
    results = append(results, d)
    }
    return results, nil
    }
{{end}}
