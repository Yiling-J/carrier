// Code generated by carrier, DO NOT EDIT.
package factory

import (
	"github.com/Yiling-J/carrier/integration/model"

	"context"
)

type groupMutation struct {
	nameType int
	nameFunc func(ctx context.Context, i *model.Group, c int) error

	afterCreateFunc func(ctx context.Context, i *model.Group) error
}
type GroupMetaFactory struct {
	mutation groupMutation
}
type groupTrait struct {
	mutation groupMutation
	updates  []func(m *groupMutation)
}

func GroupTrait() *groupTrait {
	return &groupTrait{}
}
func (*groupMutation) afterCreateMutateFunc(fn func(ctx context.Context, i *model.Group) error) func(m *groupMutation) {
	return func(m *groupMutation) {
		m.afterCreateFunc = fn
	}
}

func (*groupMutation) nameSequenceMutateFunc(fn func(ctx context.Context, i int) (string, error)) func(m *groupMutation) {
	return func(m *groupMutation) {
		m.nameType = TypeSequence
		m.nameFunc = func(ctx context.Context, i *model.Group, c int) error {
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.Name = value

			return nil
		}
	}
}
func (*groupMutation) nameLazyMutateFunc(fn func(ctx context.Context, i *model.Group) (string, error)) func(m *groupMutation) {
	return func(m *groupMutation) {
		m.nameType = TypeLazy
		m.nameFunc = func(ctx context.Context, i *model.Group, c int) error {
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.Name = value

			return nil
		}
	}
}
func (*groupMutation) nameDefaultMutateFunc(v string) func(m *groupMutation) {
	return func(m *groupMutation) {
		m.nameType = TypeDefault
		m.nameFunc = func(ctx context.Context, i *model.Group, c int) error {

			i.Name = v

			return nil
		}
	}
}
func (*groupMutation) nameFactoryMutateFunc(fn func(ctx context.Context) (string, error)) func(m *groupMutation) {
	return func(m *groupMutation) {
		m.nameType = TypeFactory
		m.nameFunc = func(ctx context.Context, i *model.Group, c int) error {
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.Name = value

			return nil
		}
	}
}

func (f *GroupMetaFactory) SetNameSequence(fn func(ctx context.Context, i int) (string, error)) *GroupMetaFactory {
	f.mutation.nameSequenceMutateFunc(fn)(&f.mutation)
	return f
}
func (f *GroupMetaFactory) SetNameLazy(fn func(ctx context.Context, i *model.Group) (string, error)) *GroupMetaFactory {
	f.mutation.nameLazyMutateFunc(fn)(&f.mutation)
	return f
}
func (f *GroupMetaFactory) SetNameDefault(v string) *GroupMetaFactory {
	f.mutation.nameDefaultMutateFunc(v)(&f.mutation)
	return f
}
func (f *GroupMetaFactory) SetNameFactory(fn func(ctx context.Context) (string, error)) *GroupMetaFactory {
	f.mutation.nameFactoryMutateFunc(fn)(&f.mutation)
	return f
}
func (t *groupTrait) SetNameSequence(fn func(ctx context.Context, i int) (string, error)) *groupTrait {
	t.updates = append(t.updates, t.mutation.nameSequenceMutateFunc(fn))
	return t
}
func (t *groupTrait) SetNameLazy(fn func(ctx context.Context, i *model.Group) (string, error)) *groupTrait {
	t.updates = append(t.updates, t.mutation.nameLazyMutateFunc(fn))
	return t
}
func (t *groupTrait) SetNameDefault(v string) *groupTrait {
	t.updates = append(t.updates, t.mutation.nameDefaultMutateFunc(v))
	return t
}
func (t *groupTrait) SetNameFactory(fn func(ctx context.Context) (string, error)) *groupTrait {
	t.updates = append(t.updates, t.mutation.nameFactoryMutateFunc(fn))
	return t
}

func (f *GroupMetaFactory) SetAfterCreateFunc(fn func(ctx context.Context, i *model.Group) error) *GroupMetaFactory {
	f.mutation.afterCreateFunc = fn
	return f
}

func (f *GroupMetaFactory) Build() *GroupFactory {
	return &GroupFactory{meta: *f, counter: &Counter{}}
}

type GroupFactory struct {
	meta    GroupMetaFactory
	counter *Counter
}

func (f *GroupFactory) SetName(i string) *GroupBuilder {
	builder := &GroupBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetName(i)
	return builder
}

func (f *GroupFactory) Create(ctx context.Context) (*model.Group, error) {
	builder := &GroupBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	return builder.Create(ctx)
}
func (f *GroupFactory) CreateV(ctx context.Context) (model.Group, error) {
	builder := &GroupBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	return builder.CreateV(ctx)
}
func (f *GroupFactory) CreateBatch(ctx context.Context, n int) ([]*model.Group, error) {
	builder := &GroupBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	return builder.CreateBatch(ctx, n)
}
func (f *GroupFactory) CreateBatchV(ctx context.Context, n int) ([]model.Group, error) {
	builder := &GroupBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	return builder.CreateBatchV(ctx, n)
}

type GroupBuilder struct {
	factory  *GroupFactory
	mutation groupMutation
	counter  *Counter

	nameOverride  string
	nameOverriden bool
}

func (b *GroupBuilder) SetName(i string) *GroupBuilder {
	b.nameOverride = i
	b.nameOverriden = true
	return b
}

func (b *GroupBuilder) CreateV(ctx context.Context) (model.Group, error) {
	var d model.Group
	p, err := b.Create(ctx)
	if err == nil {
		d = *p
	}
	return d, err
}

func (b *GroupBuilder) Create(ctx context.Context) (*model.Group, error) {

	var preSlice = []func(ctx context.Context, i *model.Group, c int) error{}
	var lazySlice = []func(ctx context.Context, i *model.Group, c int) error{}
	var postSlice = []func(ctx context.Context, i *model.Group, c int) error{}

	index := b.counter.Get()
	_ = index

	if b.nameOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *model.Group, c int) error {
			value := b.nameOverride

			i.Name = value

			return nil
		})
	} else {
		switch b.mutation.nameType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.nameFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.nameFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.nameFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.nameFunc)
		}
	}

	v := &model.Group{}
	for _, f := range preSlice {

		err := f(ctx, v, index)

		if err != nil {
			return nil, err
		}
	}
	for _, f := range lazySlice {

		err := f(ctx, v, index)

		if err != nil {
			return nil, err
		}
	}

	if b.mutation.afterCreateFunc != nil {
		err := b.mutation.afterCreateFunc(ctx, v)
		if err != nil {
			return nil, err
		}
	}
	for _, f := range postSlice {

		err := f(ctx, v, index)

		if err != nil {
			return nil, err
		}
	}

	return v, nil
}
func (b *GroupBuilder) CreateBatch(ctx context.Context, n int) ([]*model.Group, error) {
	var results []*model.Group
	for i := 0; i < n; i++ {
		d, err := b.Create(ctx)
		if err != nil {
			return results, err
		}
		results = append(results, d)
	}
	return results, nil
}
func (b *GroupBuilder) CreateBatchV(ctx context.Context, n int) ([]model.Group, error) {
	var results []model.Group
	for i := 0; i < n; i++ {
		d, err := b.CreateV(ctx)
		if err != nil {
			return results, err
		}
		results = append(results, d)
	}
	return results, nil
}
