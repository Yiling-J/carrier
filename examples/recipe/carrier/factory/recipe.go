// Code generated by carrier, DO NOT EDIT.
package factory

import (
	"github.com/Yiling-J/carrier/examples/recipe/model"

	"context"
)

type recipeMutation struct {
	nameType int
	nameFunc func(ctx context.Context, i *model.Recipe, c int) error

	authorNameType int
	authorNameFunc func(ctx context.Context, i *model.Recipe, c int) error

	servingsType int
	servingsFunc func(ctx context.Context, i *model.Recipe, c int) error

	stepsType int
	stepsFunc func(ctx context.Context, i *model.Recipe, c int) error

	ingredientsType int
	ingredientsFunc func(ctx context.Context, i *model.Recipe, c int) error

	tagsType int
	tagsFunc func(ctx context.Context, i *model.Recipe, c int) error

	relatedType int
	relatedFunc func(ctx context.Context, i *model.Recipe, c int) error

	_postStepsCountFunc func(ctx context.Context, set bool, obj *model.Recipe, i int) error

	_postIngredientsCountFunc func(ctx context.Context, set bool, obj *model.Recipe, i int) error

	afterCreateFunc func(ctx context.Context, i *model.Recipe) error
}
type RecipeMetaFactory struct {
	mutation recipeMutation

	veganTrait *recipeTrait

	ketoTrait *recipeTrait
}
type recipeTrait struct {
	mutation recipeMutation
	updates  []func(m *recipeMutation)
}

func RecipeTrait() *recipeTrait {
	return &recipeTrait{}
}
func (*recipeMutation) afterCreateMutateFunc(fn func(ctx context.Context, i *model.Recipe) error) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.afterCreateFunc = fn
	}
}

func (*recipeMutation) nameSequenceMutateFunc(fn func(ctx context.Context, i int) (string, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.nameType = TypeSequence
		m.nameFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.Name = value
			return nil
		}
	}
}
func (*recipeMutation) nameLazyMutateFunc(fn func(ctx context.Context, i *model.Recipe) (string, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.nameType = TypeLazy
		m.nameFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.Name = value
			return nil
		}
	}
}
func (*recipeMutation) nameDefaultMutateFunc(v string) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.nameType = TypeDefault
		m.nameFunc = func(ctx context.Context, i *model.Recipe, c int) error {

			i.Name = v
			return nil
		}
	}
}
func (*recipeMutation) nameFactoryMutateFunc(fn func(ctx context.Context) (string, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.nameType = TypeFactory
		m.nameFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.Name = value

			return nil
		}
	}
}

func (f *RecipeMetaFactory) SetNameSequence(fn func(ctx context.Context, i int) (string, error)) *RecipeMetaFactory {
	f.mutation.nameSequenceMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetNameLazy(fn func(ctx context.Context, i *model.Recipe) (string, error)) *RecipeMetaFactory {
	f.mutation.nameLazyMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetNameDefault(v string) *RecipeMetaFactory {
	f.mutation.nameDefaultMutateFunc(v)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetNameFactory(fn func(ctx context.Context) (string, error)) *RecipeMetaFactory {
	f.mutation.nameFactoryMutateFunc(fn)(&f.mutation)
	return f
}
func (t *recipeTrait) SetNameSequence(fn func(ctx context.Context, i int) (string, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.nameSequenceMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetNameLazy(fn func(ctx context.Context, i *model.Recipe) (string, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.nameLazyMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetNameDefault(v string) *recipeTrait {
	t.updates = append(t.updates, t.mutation.nameDefaultMutateFunc(v))
	return t
}
func (t *recipeTrait) SetNameFactory(fn func(ctx context.Context) (string, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.nameFactoryMutateFunc(fn))
	return t
}

func (*recipeMutation) authorNameSequenceMutateFunc(fn func(ctx context.Context, i int) (string, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.authorNameType = TypeSequence
		m.authorNameFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.AuthorName = value
			return nil
		}
	}
}
func (*recipeMutation) authorNameLazyMutateFunc(fn func(ctx context.Context, i *model.Recipe) (string, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.authorNameType = TypeLazy
		m.authorNameFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.AuthorName = value
			return nil
		}
	}
}
func (*recipeMutation) authorNameDefaultMutateFunc(v string) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.authorNameType = TypeDefault
		m.authorNameFunc = func(ctx context.Context, i *model.Recipe, c int) error {

			i.AuthorName = v
			return nil
		}
	}
}
func (*recipeMutation) authorNameFactoryMutateFunc(fn func(ctx context.Context) (string, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.authorNameType = TypeFactory
		m.authorNameFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.AuthorName = value

			return nil
		}
	}
}

func (f *RecipeMetaFactory) SetAuthorNameSequence(fn func(ctx context.Context, i int) (string, error)) *RecipeMetaFactory {
	f.mutation.authorNameSequenceMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetAuthorNameLazy(fn func(ctx context.Context, i *model.Recipe) (string, error)) *RecipeMetaFactory {
	f.mutation.authorNameLazyMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetAuthorNameDefault(v string) *RecipeMetaFactory {
	f.mutation.authorNameDefaultMutateFunc(v)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetAuthorNameFactory(fn func(ctx context.Context) (string, error)) *RecipeMetaFactory {
	f.mutation.authorNameFactoryMutateFunc(fn)(&f.mutation)
	return f
}
func (t *recipeTrait) SetAuthorNameSequence(fn func(ctx context.Context, i int) (string, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.authorNameSequenceMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetAuthorNameLazy(fn func(ctx context.Context, i *model.Recipe) (string, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.authorNameLazyMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetAuthorNameDefault(v string) *recipeTrait {
	t.updates = append(t.updates, t.mutation.authorNameDefaultMutateFunc(v))
	return t
}
func (t *recipeTrait) SetAuthorNameFactory(fn func(ctx context.Context) (string, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.authorNameFactoryMutateFunc(fn))
	return t
}

func (*recipeMutation) servingsSequenceMutateFunc(fn func(ctx context.Context, i int) (int, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.servingsType = TypeSequence
		m.servingsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.Servings = value
			return nil
		}
	}
}
func (*recipeMutation) servingsLazyMutateFunc(fn func(ctx context.Context, i *model.Recipe) (int, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.servingsType = TypeLazy
		m.servingsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.Servings = value
			return nil
		}
	}
}
func (*recipeMutation) servingsDefaultMutateFunc(v int) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.servingsType = TypeDefault
		m.servingsFunc = func(ctx context.Context, i *model.Recipe, c int) error {

			i.Servings = v
			return nil
		}
	}
}
func (*recipeMutation) servingsFactoryMutateFunc(fn func(ctx context.Context) (int, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.servingsType = TypeFactory
		m.servingsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.Servings = value

			return nil
		}
	}
}

func (f *RecipeMetaFactory) SetServingsSequence(fn func(ctx context.Context, i int) (int, error)) *RecipeMetaFactory {
	f.mutation.servingsSequenceMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetServingsLazy(fn func(ctx context.Context, i *model.Recipe) (int, error)) *RecipeMetaFactory {
	f.mutation.servingsLazyMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetServingsDefault(v int) *RecipeMetaFactory {
	f.mutation.servingsDefaultMutateFunc(v)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetServingsFactory(fn func(ctx context.Context) (int, error)) *RecipeMetaFactory {
	f.mutation.servingsFactoryMutateFunc(fn)(&f.mutation)
	return f
}
func (t *recipeTrait) SetServingsSequence(fn func(ctx context.Context, i int) (int, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.servingsSequenceMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetServingsLazy(fn func(ctx context.Context, i *model.Recipe) (int, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.servingsLazyMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetServingsDefault(v int) *recipeTrait {
	t.updates = append(t.updates, t.mutation.servingsDefaultMutateFunc(v))
	return t
}
func (t *recipeTrait) SetServingsFactory(fn func(ctx context.Context) (int, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.servingsFactoryMutateFunc(fn))
	return t
}

func (*recipeMutation) stepsSequenceMutateFunc(fn func(ctx context.Context, i int) ([]*model.RecipeStep, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.stepsType = TypeSequence
		m.stepsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.Steps = value
			return nil
		}
	}
}
func (*recipeMutation) stepsLazyMutateFunc(fn func(ctx context.Context, i *model.Recipe) ([]*model.RecipeStep, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.stepsType = TypeLazy
		m.stepsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.Steps = value
			return nil
		}
	}
}
func (*recipeMutation) stepsDefaultMutateFunc(v []*model.RecipeStep) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.stepsType = TypeDefault
		m.stepsFunc = func(ctx context.Context, i *model.Recipe, c int) error {

			i.Steps = v
			return nil
		}
	}
}
func (*recipeMutation) stepsFactoryMutateFunc(fn func(ctx context.Context) ([]*model.RecipeStep, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.stepsType = TypeFactory
		m.stepsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.Steps = value

			return nil
		}
	}
}

func (f *RecipeMetaFactory) SetStepsSequence(fn func(ctx context.Context, i int) ([]*model.RecipeStep, error)) *RecipeMetaFactory {
	f.mutation.stepsSequenceMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetStepsLazy(fn func(ctx context.Context, i *model.Recipe) ([]*model.RecipeStep, error)) *RecipeMetaFactory {
	f.mutation.stepsLazyMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetStepsDefault(v []*model.RecipeStep) *RecipeMetaFactory {
	f.mutation.stepsDefaultMutateFunc(v)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetStepsFactory(fn func(ctx context.Context) ([]*model.RecipeStep, error)) *RecipeMetaFactory {
	f.mutation.stepsFactoryMutateFunc(fn)(&f.mutation)
	return f
}
func (t *recipeTrait) SetStepsSequence(fn func(ctx context.Context, i int) ([]*model.RecipeStep, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.stepsSequenceMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetStepsLazy(fn func(ctx context.Context, i *model.Recipe) ([]*model.RecipeStep, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.stepsLazyMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetStepsDefault(v []*model.RecipeStep) *recipeTrait {
	t.updates = append(t.updates, t.mutation.stepsDefaultMutateFunc(v))
	return t
}
func (t *recipeTrait) SetStepsFactory(fn func(ctx context.Context) ([]*model.RecipeStep, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.stepsFactoryMutateFunc(fn))
	return t
}

func (*recipeMutation) ingredientsSequenceMutateFunc(fn func(ctx context.Context, i int) ([]*model.RecipeIngredient, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.ingredientsType = TypeSequence
		m.ingredientsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.Ingredients = value
			return nil
		}
	}
}
func (*recipeMutation) ingredientsLazyMutateFunc(fn func(ctx context.Context, i *model.Recipe) ([]*model.RecipeIngredient, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.ingredientsType = TypeLazy
		m.ingredientsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.Ingredients = value
			return nil
		}
	}
}
func (*recipeMutation) ingredientsDefaultMutateFunc(v []*model.RecipeIngredient) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.ingredientsType = TypeDefault
		m.ingredientsFunc = func(ctx context.Context, i *model.Recipe, c int) error {

			i.Ingredients = v
			return nil
		}
	}
}
func (*recipeMutation) ingredientsFactoryMutateFunc(fn func(ctx context.Context) ([]*model.RecipeIngredient, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.ingredientsType = TypeFactory
		m.ingredientsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.Ingredients = value

			return nil
		}
	}
}

func (f *RecipeMetaFactory) SetIngredientsSequence(fn func(ctx context.Context, i int) ([]*model.RecipeIngredient, error)) *RecipeMetaFactory {
	f.mutation.ingredientsSequenceMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetIngredientsLazy(fn func(ctx context.Context, i *model.Recipe) ([]*model.RecipeIngredient, error)) *RecipeMetaFactory {
	f.mutation.ingredientsLazyMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetIngredientsDefault(v []*model.RecipeIngredient) *RecipeMetaFactory {
	f.mutation.ingredientsDefaultMutateFunc(v)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetIngredientsFactory(fn func(ctx context.Context) ([]*model.RecipeIngredient, error)) *RecipeMetaFactory {
	f.mutation.ingredientsFactoryMutateFunc(fn)(&f.mutation)
	return f
}
func (t *recipeTrait) SetIngredientsSequence(fn func(ctx context.Context, i int) ([]*model.RecipeIngredient, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.ingredientsSequenceMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetIngredientsLazy(fn func(ctx context.Context, i *model.Recipe) ([]*model.RecipeIngredient, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.ingredientsLazyMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetIngredientsDefault(v []*model.RecipeIngredient) *recipeTrait {
	t.updates = append(t.updates, t.mutation.ingredientsDefaultMutateFunc(v))
	return t
}
func (t *recipeTrait) SetIngredientsFactory(fn func(ctx context.Context) ([]*model.RecipeIngredient, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.ingredientsFactoryMutateFunc(fn))
	return t
}

func (*recipeMutation) tagsSequenceMutateFunc(fn func(ctx context.Context, i int) ([]*model.Category, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.tagsType = TypeSequence
		m.tagsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.Tags = value
			return nil
		}
	}
}
func (*recipeMutation) tagsLazyMutateFunc(fn func(ctx context.Context, i *model.Recipe) ([]*model.Category, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.tagsType = TypeLazy
		m.tagsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.Tags = value
			return nil
		}
	}
}
func (*recipeMutation) tagsDefaultMutateFunc(v []*model.Category) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.tagsType = TypeDefault
		m.tagsFunc = func(ctx context.Context, i *model.Recipe, c int) error {

			i.Tags = v
			return nil
		}
	}
}
func (*recipeMutation) tagsFactoryMutateFunc(fn func(ctx context.Context) ([]*model.Category, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.tagsType = TypeFactory
		m.tagsFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.Tags = value

			return nil
		}
	}
}

func (f *RecipeMetaFactory) SetTagsSequence(fn func(ctx context.Context, i int) ([]*model.Category, error)) *RecipeMetaFactory {
	f.mutation.tagsSequenceMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetTagsLazy(fn func(ctx context.Context, i *model.Recipe) ([]*model.Category, error)) *RecipeMetaFactory {
	f.mutation.tagsLazyMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetTagsDefault(v []*model.Category) *RecipeMetaFactory {
	f.mutation.tagsDefaultMutateFunc(v)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetTagsFactory(fn func(ctx context.Context) ([]*model.Category, error)) *RecipeMetaFactory {
	f.mutation.tagsFactoryMutateFunc(fn)(&f.mutation)
	return f
}
func (t *recipeTrait) SetTagsSequence(fn func(ctx context.Context, i int) ([]*model.Category, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.tagsSequenceMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetTagsLazy(fn func(ctx context.Context, i *model.Recipe) ([]*model.Category, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.tagsLazyMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetTagsDefault(v []*model.Category) *recipeTrait {
	t.updates = append(t.updates, t.mutation.tagsDefaultMutateFunc(v))
	return t
}
func (t *recipeTrait) SetTagsFactory(fn func(ctx context.Context) ([]*model.Category, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.tagsFactoryMutateFunc(fn))
	return t
}

func (*recipeMutation) relatedSequenceMutateFunc(fn func(ctx context.Context, i int) ([]*model.Recipe, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.relatedType = TypeSequence
		m.relatedFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.Related = value
			return nil
		}
	}
}
func (*recipeMutation) relatedLazyMutateFunc(fn func(ctx context.Context, i *model.Recipe) ([]*model.Recipe, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.relatedType = TypeLazy
		m.relatedFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.Related = value
			return nil
		}
	}
}
func (*recipeMutation) relatedDefaultMutateFunc(v []*model.Recipe) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.relatedType = TypeDefault
		m.relatedFunc = func(ctx context.Context, i *model.Recipe, c int) error {

			i.Related = v
			return nil
		}
	}
}
func (*recipeMutation) relatedFactoryMutateFunc(fn func(ctx context.Context) ([]*model.Recipe, error)) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m.relatedType = TypeFactory
		m.relatedFunc = func(ctx context.Context, i *model.Recipe, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.Related = value

			return nil
		}
	}
}

func (f *RecipeMetaFactory) SetRelatedSequence(fn func(ctx context.Context, i int) ([]*model.Recipe, error)) *RecipeMetaFactory {
	f.mutation.relatedSequenceMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetRelatedLazy(fn func(ctx context.Context, i *model.Recipe) ([]*model.Recipe, error)) *RecipeMetaFactory {
	f.mutation.relatedLazyMutateFunc(fn)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetRelatedDefault(v []*model.Recipe) *RecipeMetaFactory {
	f.mutation.relatedDefaultMutateFunc(v)(&f.mutation)
	return f
}
func (f *RecipeMetaFactory) SetRelatedFactory(fn func(ctx context.Context) ([]*model.Recipe, error)) *RecipeMetaFactory {
	f.mutation.relatedFactoryMutateFunc(fn)(&f.mutation)
	return f
}
func (t *recipeTrait) SetRelatedSequence(fn func(ctx context.Context, i int) ([]*model.Recipe, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.relatedSequenceMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetRelatedLazy(fn func(ctx context.Context, i *model.Recipe) ([]*model.Recipe, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.relatedLazyMutateFunc(fn))
	return t
}
func (t *recipeTrait) SetRelatedDefault(v []*model.Recipe) *recipeTrait {
	t.updates = append(t.updates, t.mutation.relatedDefaultMutateFunc(v))
	return t
}
func (t *recipeTrait) SetRelatedFactory(fn func(ctx context.Context) ([]*model.Recipe, error)) *recipeTrait {
	t.updates = append(t.updates, t.mutation.relatedFactoryMutateFunc(fn))
	return t
}

func (*recipeMutation) stepsCountPostMutateFunc(fn func(ctx context.Context, set bool, obj *model.Recipe, i int) error) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m._postStepsCountFunc = fn
	}
}
func (f *RecipeMetaFactory) SetStepsCountPostFunc(fn func(ctx context.Context, set bool, obj *model.Recipe, i int) error) *RecipeMetaFactory {
	f.mutation.stepsCountPostMutateFunc(fn)(&f.mutation)
	return f
}
func (t *recipeTrait) SetStepsCountPostFunc(fn func(ctx context.Context, set bool, obj *model.Recipe, i int) error) *recipeTrait {
	t.updates = append(t.updates, t.mutation.stepsCountPostMutateFunc(fn))
	return t
}

func (*recipeMutation) ingredientsCountPostMutateFunc(fn func(ctx context.Context, set bool, obj *model.Recipe, i int) error) func(m *recipeMutation) {
	return func(m *recipeMutation) {
		m._postIngredientsCountFunc = fn
	}
}
func (f *RecipeMetaFactory) SetIngredientsCountPostFunc(fn func(ctx context.Context, set bool, obj *model.Recipe, i int) error) *RecipeMetaFactory {
	f.mutation.ingredientsCountPostMutateFunc(fn)(&f.mutation)
	return f
}
func (t *recipeTrait) SetIngredientsCountPostFunc(fn func(ctx context.Context, set bool, obj *model.Recipe, i int) error) *recipeTrait {
	t.updates = append(t.updates, t.mutation.ingredientsCountPostMutateFunc(fn))
	return t
}

func (f *RecipeMetaFactory) SetVeganTrait(t *recipeTrait) *RecipeMetaFactory {
	f.veganTrait = t
	return f
}

func (f *RecipeMetaFactory) SetKetoTrait(t *recipeTrait) *RecipeMetaFactory {
	f.ketoTrait = t
	return f
}

func (f *RecipeMetaFactory) SetAfterCreateFunc(fn func(ctx context.Context, i *model.Recipe) error) *RecipeMetaFactory {
	f.mutation.afterCreateFunc = fn
	return f
}
func (t *recipeTrait) SetAfterCreateFunc(fn func(ctx context.Context, i *model.Recipe) error) *recipeTrait {
	t.updates = append(t.updates, t.mutation.afterCreateMutateFunc(fn))
	return t
}

func (f *RecipeMetaFactory) Build() *RecipeFactory {
	return &RecipeFactory{meta: *f, counter: &Counter{}}
}

type RecipeFactory struct {
	meta    RecipeMetaFactory
	counter *Counter
}

func (f *RecipeFactory) SetName(i string) *RecipeBuilder {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetName(i)

	return builder
}

func (f *RecipeFactory) SetAuthorName(i string) *RecipeBuilder {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetAuthorName(i)

	return builder
}

func (f *RecipeFactory) SetServings(i int) *RecipeBuilder {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetServings(i)

	return builder
}

func (f *RecipeFactory) SetSteps(i []*model.RecipeStep) *RecipeBuilder {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetSteps(i)

	return builder
}

func (f *RecipeFactory) SetIngredients(i []*model.RecipeIngredient) *RecipeBuilder {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetIngredients(i)

	return builder
}

func (f *RecipeFactory) SetTags(i []*model.Category) *RecipeBuilder {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetTags(i)

	return builder
}

func (f *RecipeFactory) SetRelated(i []*model.Recipe) *RecipeBuilder {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetRelated(i)

	return builder
}

func (f *RecipeFactory) SetStepsCountPost(i int) *RecipeBuilder {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetStepsCountPost(i)

	return builder
}

func (f *RecipeFactory) SetIngredientsCountPost(i int) *RecipeBuilder {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetIngredientsCountPost(i)

	return builder
}

func (f *RecipeFactory) WithVeganTrait() *RecipeBuilder {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter}
	builder.factory = f

	if f.meta.veganTrait == nil {
		return builder
	}
	for _, u := range f.meta.veganTrait.updates {
		u(&builder.mutation)
	}
	return builder
}

func (f *RecipeFactory) WithKetoTrait() *RecipeBuilder {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter}
	builder.factory = f

	if f.meta.ketoTrait == nil {
		return builder
	}
	for _, u := range f.meta.ketoTrait.updates {
		u(&builder.mutation)
	}
	return builder
}

func (f *RecipeFactory) Create(ctx context.Context) (*model.Recipe, error) {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	return builder.Create(ctx)
}
func (f *RecipeFactory) CreateV(ctx context.Context) (model.Recipe, error) {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	return builder.CreateV(ctx)
}
func (f *RecipeFactory) CreateBatch(ctx context.Context, n int) ([]*model.Recipe, error) {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	return builder.CreateBatch(ctx, n)
}
func (f *RecipeFactory) CreateBatchV(ctx context.Context, n int) ([]model.Recipe, error) {
	builder := &RecipeBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	return builder.CreateBatchV(ctx, n)
}

type RecipeBuilder struct {
	factory  *RecipeFactory
	mutation recipeMutation
	counter  *Counter

	nameOverride  string
	nameOverriden bool

	authorNameOverride  string
	authorNameOverriden bool

	servingsOverride  int
	servingsOverriden bool

	stepsOverride  []*model.RecipeStep
	stepsOverriden bool

	ingredientsOverride  []*model.RecipeIngredient
	ingredientsOverriden bool

	tagsOverride  []*model.Category
	tagsOverriden bool

	relatedOverride  []*model.Recipe
	relatedOverriden bool

	_postStepsCount    int
	_postStepsCountSet bool

	_postIngredientsCount    int
	_postIngredientsCountSet bool
}

func (b *RecipeBuilder) SetName(i string) *RecipeBuilder {
	b.nameOverride = i
	b.nameOverriden = true
	return b
}

func (b *RecipeBuilder) SetAuthorName(i string) *RecipeBuilder {
	b.authorNameOverride = i
	b.authorNameOverriden = true
	return b
}

func (b *RecipeBuilder) SetServings(i int) *RecipeBuilder {
	b.servingsOverride = i
	b.servingsOverriden = true
	return b
}

func (b *RecipeBuilder) SetSteps(i []*model.RecipeStep) *RecipeBuilder {
	b.stepsOverride = i
	b.stepsOverriden = true
	return b
}

func (b *RecipeBuilder) SetIngredients(i []*model.RecipeIngredient) *RecipeBuilder {
	b.ingredientsOverride = i
	b.ingredientsOverriden = true
	return b
}

func (b *RecipeBuilder) SetTags(i []*model.Category) *RecipeBuilder {
	b.tagsOverride = i
	b.tagsOverriden = true
	return b
}

func (b *RecipeBuilder) SetRelated(i []*model.Recipe) *RecipeBuilder {
	b.relatedOverride = i
	b.relatedOverriden = true
	return b
}

func (b *RecipeBuilder) SetStepsCountPost(i int) *RecipeBuilder {
	b._postStepsCount = i
	b._postStepsCountSet = true
	return b
}

func (b *RecipeBuilder) SetIngredientsCountPost(i int) *RecipeBuilder {
	b._postIngredientsCount = i
	b._postIngredientsCountSet = true
	return b
}

func (b *RecipeBuilder) WithVeganTrait() *RecipeBuilder {
	if b.factory.meta.veganTrait == nil {
		return b
	}
	for _, u := range b.factory.meta.veganTrait.updates {
		u(&b.mutation)
	}
	return b
}

func (b *RecipeBuilder) WithKetoTrait() *RecipeBuilder {
	if b.factory.meta.ketoTrait == nil {
		return b
	}
	for _, u := range b.factory.meta.ketoTrait.updates {
		u(&b.mutation)
	}
	return b
}

func (b *RecipeBuilder) CreateV(ctx context.Context) (model.Recipe, error) {
	var d model.Recipe
	p, err := b.Create(ctx)
	if err == nil {
		d = *p
	}
	return d, err
}

func (b *RecipeBuilder) Create(ctx context.Context) (*model.Recipe, error) {

	var preSlice = []func(ctx context.Context, i *model.Recipe, c int) error{}
	var lazySlice = []func(ctx context.Context, i *model.Recipe, c int) error{}
	var postSlice = []func(ctx context.Context, i *model.Recipe, c int) error{}

	index := b.counter.Get()
	_ = index

	if b.nameOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *model.Recipe, c int) error {
			value := b.nameOverride

			i.Name = value
			return nil
		})
	} else {
		switch b.mutation.nameType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.nameFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.nameFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.nameFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.nameFunc)
		}
	}

	if b.authorNameOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *model.Recipe, c int) error {
			value := b.authorNameOverride

			i.AuthorName = value
			return nil
		})
	} else {
		switch b.mutation.authorNameType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.authorNameFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.authorNameFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.authorNameFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.authorNameFunc)
		}
	}

	if b.servingsOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *model.Recipe, c int) error {
			value := b.servingsOverride

			i.Servings = value
			return nil
		})
	} else {
		switch b.mutation.servingsType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.servingsFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.servingsFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.servingsFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.servingsFunc)
		}
	}

	if b.stepsOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *model.Recipe, c int) error {
			value := b.stepsOverride

			i.Steps = value
			return nil
		})
	} else {
		switch b.mutation.stepsType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.stepsFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.stepsFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.stepsFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.stepsFunc)
		}
	}

	if b.ingredientsOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *model.Recipe, c int) error {
			value := b.ingredientsOverride

			i.Ingredients = value
			return nil
		})
	} else {
		switch b.mutation.ingredientsType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.ingredientsFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.ingredientsFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.ingredientsFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.ingredientsFunc)
		}
	}

	if b.tagsOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *model.Recipe, c int) error {
			value := b.tagsOverride

			i.Tags = value
			return nil
		})
	} else {
		switch b.mutation.tagsType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.tagsFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.tagsFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.tagsFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.tagsFunc)
		}
	}

	if b.relatedOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *model.Recipe, c int) error {
			value := b.relatedOverride

			i.Related = value
			return nil
		})
	} else {
		switch b.mutation.relatedType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.relatedFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.relatedFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.relatedFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.relatedFunc)
		}
	}

	if b.mutation._postStepsCountFunc != nil {
		postSlice = append(postSlice, func(ctx context.Context, i *model.Recipe, c int) error {
			err := b.mutation._postStepsCountFunc(ctx, b._postStepsCountSet, i, b._postStepsCount)
			return err
		})
	}

	if b.mutation._postIngredientsCountFunc != nil {
		postSlice = append(postSlice, func(ctx context.Context, i *model.Recipe, c int) error {
			err := b.mutation._postIngredientsCountFunc(ctx, b._postIngredientsCountSet, i, b._postIngredientsCount)
			return err
		})
	}

	v := &model.Recipe{}
	for _, f := range preSlice {

		err := f(ctx, v, index)

		if err != nil {
			return nil, err
		}
	}
	for _, f := range lazySlice {

		err := f(ctx, v, index)

		if err != nil {
			return nil, err
		}
	}

	new := v

	if b.mutation.afterCreateFunc != nil {
		err := b.mutation.afterCreateFunc(ctx, new)
		if err != nil {
			return nil, err
		}
	}
	for _, f := range postSlice {

		err := f(ctx, new, index)

		if err != nil {
			return nil, err
		}
	}

	return new, nil
}
func (b *RecipeBuilder) CreateBatch(ctx context.Context, n int) ([]*model.Recipe, error) {
	var results []*model.Recipe
	for i := 0; i < n; i++ {
		d, err := b.Create(ctx)
		if err != nil {
			return results, err
		}
		results = append(results, d)
	}
	return results, nil
}
func (b *RecipeBuilder) CreateBatchV(ctx context.Context, n int) ([]model.Recipe, error) {
	var results []model.Recipe
	for i := 0; i < n; i++ {
		d, err := b.CreateV(ctx)
		if err != nil {
			return results, err
		}
		results = append(results, d)
	}
	return results, nil
}
